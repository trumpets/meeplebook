package app.meeplebook.core.database.dao

import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import app.meeplebook.core.database.MeepleBookDatabase
import app.meeplebook.core.database.entity.PlayEntity
import app.meeplebook.core.database.entity.PlayerEntity
import app.meeplebook.core.plays.model.PlaySyncStatus
import app.meeplebook.core.util.parseDateString
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.time.Instant

/**
 * Room DAO tests for [PlayerDao].
 * Tests only the DAO layer with an in-memory database.
 */
@RunWith(AndroidJUnit4::class)
class PlayerDaoTest {

    private lateinit var database: MeepleBookDatabase
    private lateinit var playDao: PlayDao
    private lateinit var playerDao: PlayerDao

    @Before
    fun setUp() {
        // Create an in-memory database for testing
        database = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            MeepleBookDatabase::class.java
        )
            .allowMainThreadQueries() // For test convenience
            .build()

        playDao = database.playDao()
        playerDao = database.playerDao()
    }

    @After
    fun tearDown() {
        database.close()
    }

    // --- Test 1: Insert players & read them back ---

    @Test
    fun insertAndReadPlayer() = runTest {
        // Insert a play first (foreign key requirement)
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert a single player
        val player = createTestPlayer(
            id = 0,
            playId = 1,
            name = "Alice",
            username = "alice123",
            win = true
        )
        playerDao.insert(player)

        // Read it back
        val result = playerDao.getPlayersForPlay(1)

        assertEquals(1, result.size)
        assertEquals("Alice", result[0].name)
        assertEquals("alice123", result[0].username)
        assertTrue(result[0].win)
    }

    @Test
    fun insertMultiplePlayersAndReadThemBack() = runTest {
        // Insert a play
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert multiple players
        val players = listOf(
            createTestPlayer(0, 1, "Alice", "alice123", true),
            createTestPlayer(0, 1, "Bob", "bob456", false),
            createTestPlayer(0, 1, "Charlie", null, false)
        )
        playerDao.insertAll(players)

        // Read them back
        val result = playerDao.getPlayersForPlay(1)

        assertEquals(3, result.size)
        assertEquals("Alice", result[0].name)
        assertEquals("Bob", result[1].name)
        assertEquals("Charlie", result[2].name)
    }

    @Test
    fun insertPlayerWithNullFields() = runTest {
        // Insert play
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert player with null optional fields
        val player = createTestPlayer(
            id = 0,
            playId = 1,
            name = "Player",
            username = null,
            userId = null,
            startPosition = null,
            color = null,
            score = null,
            win = false
        )
        playerDao.insert(player)

        // Read it back
        val result = playerDao.getPlayersForPlay(1)

        assertEquals(1, result.size)
        assertEquals("Player", result[0].name)
        assertEquals(null, result[0].username)
        assertEquals(null, result[0].userId)
        assertEquals(null, result[0].startPosition)
        assertEquals(null, result[0].color)
        assertEquals(null, result[0].score)
    }

    // --- Test 2: Auto-generated ID ---

    @Test
    fun playerIdIsAutoGenerated() = runTest {
        // Insert play
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert players with id=0 (auto-generate)
        val player1 = createTestPlayer(0, 1, "Alice", null, true)
        val player2 = createTestPlayer(0, 1, "Bob", null, false)
        
        playerDao.insert(player1)
        playerDao.insert(player2)

        // Read them back
        val result = playerDao.getPlayersForPlay(1)

        assertEquals(2, result.size)
        // Verify IDs were auto-generated and are different
        assertTrue(result[0].id > 0)
        assertTrue(result[1].id > 0)
        assertTrue(result[0].id != result[1].id)
    }

    // --- Test 3: Upsert behavior with OnConflictStrategy.REPLACE ---

    @Test
    fun upsertReplacesExistingPlayer() = runTest {
        // Insert play
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert initial player with specific ID
        val originalPlayer = createTestPlayer(
            id = 10,
            playId = 1,
            name = "Original Name",
            username = "testplayer",
            win = false
        )
        playerDao.insert(originalPlayer)

        // Verify initial insert
        var result = playerDao.getPlayersForPlay(1)
        assertEquals(1, result.size)
        assertEquals("Original Name", result[0].name)
        assertEquals(false, result[0].win)

        // Insert same id with different fields (upsert)
        val updatedPlayer = createTestPlayer(
            id = 10, // Same ID
            playId = 1,
            name = "Updated Name",
            username = "testplayer",
            win = true
        )
        playerDao.insert(updatedPlayer)

        // Verify the player was updated, not duplicated
        result = playerDao.getPlayersForPlay(1)
        assertEquals(1, result.size)
        assertEquals("Updated Name", result[0].name)
        assertTrue(result[0].win)
    }

    // --- Test 4: Players for multiple plays ---

    @Test
    fun getPlayersForDifferentPlays() = runTest {
        // Insert multiple plays
        playDao.insertAll(
            listOf(
                createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"),
                createTestPlay(2, parseDateString("2024-01-02"), 200, "Game 2")
            )
        )

        // Insert players for play 1
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false)
            )
        )

        // Insert players for play 2
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 2, "Charlie", null, true),
                createTestPlayer(0, 2, "Dave", null, false),
                createTestPlayer(0, 2, "Eve", null, false)
            )
        )

        // Query players for each play
        val play1Players = playerDao.getPlayersForPlay(1)
        val play2Players = playerDao.getPlayersForPlay(2)

        assertEquals(2, play1Players.size)
        assertEquals(3, play2Players.size)
        assertTrue(play1Players.all { it.playId == 1L })
        assertTrue(play2Players.all { it.playId == 2L })
    }

    @Test
    fun getPlayersForPlayReturnsEmptyListForNonExistentPlay() = runTest {
        // Insert play and players
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))
        playerDao.insert(createTestPlayer(0, 1, "Alice", null, true))

        // Query players for non-existent play
        val result = playerDao.getPlayersForPlay(999)

        assertTrue(result.isEmpty())
    }

    // --- Test 5: Delete operations ---

    @Test
    fun deletePlayersForPlayRemovesOnlySpecifiedPlayPlayers() = runTest {
        // Insert multiple plays
        playDao.insertAll(
            listOf(
                createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"),
                createTestPlay(2, parseDateString("2024-01-02"), 200, "Game 2")
            )
        )

        // Insert players for each play
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false)
            )
        )
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 2, "Charlie", null, true)
            )
        )

        // Delete players for play 1
        playerDao.deletePlayersForPlay(1)

        // Verify play 1 players deleted
        val play1Players = playerDao.getPlayersForPlay(1)
        assertTrue(play1Players.isEmpty())

        // Verify play 2 players still exist
        val play2Players = playerDao.getPlayersForPlay(2)
        assertEquals(1, play2Players.size)
        assertEquals("Charlie", play2Players[0].name)
    }

    @Test
    fun deleteAllRemovesAllPlayers() = runTest {
        // Insert plays
        playDao.insertAll(
            listOf(
                createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"),
                createTestPlay(2, parseDateString("2024-01-02"), 200, "Game 2")
            )
        )

        // Insert players for each play
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 2, "Bob", null, true)
            )
        )

        // Verify players exist
        var play1Players = playerDao.getPlayersForPlay(1)
        var play2Players = playerDao.getPlayersForPlay(2)
        assertEquals(1, play1Players.size)
        assertEquals(1, play2Players.size)

        // Delete all
        playerDao.deleteAll()

        // Verify all deleted
        play1Players = playerDao.getPlayersForPlay(1)
        play2Players = playerDao.getPlayersForPlay(2)
        assertTrue(play1Players.isEmpty())
        assertTrue(play2Players.isEmpty())
    }

    @Test
    fun deleteAllOnEmptyDatabaseDoesNotFail() = runTest {
        // Delete on empty database
        playerDao.deleteAll()

        // Verify still empty
        val result = playerDao.getPlayersForPlay(1)
        assertTrue(result.isEmpty())
    }

    // --- Test 6: Foreign key constraint ---

    @Test
    fun cannotInsertPlayerWithoutPlay() = runTest {
        // Try to insert player without corresponding play
        val player = createTestPlayer(0, 999, "Alice", null, true)

        var exceptionThrown = false
        try {
            playerDao.insert(player)
            // Force transaction to complete
            playerDao.getPlayersForPlay(999)
        } catch (e: Exception) {
            exceptionThrown = true
        }

        assertTrue(exceptionThrown)
    }

    // --- Test 7: Observe players as Flow ---

    @Test
    fun observePlayersForPlayEmitsInitialEmptyList() = runTest {
        // Insert play without players
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Observe players
        val result = playerDao.observePlayersForPlay(1).first()

        assertTrue(result.isEmpty())
    }

    @Test
    fun observePlayersForPlayEmitsAfterInsert() = runTest {
        // Insert play
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))

        // Insert players
        val players = listOf(
            createTestPlayer(0, 1, "Alice", null, true),
            createTestPlayer(0, 1, "Bob", null, false)
        )
        playerDao.insertAll(players)

        // Observe and collect first emission
        val result = playerDao.observePlayersForPlay(1).first()

        assertEquals(2, result.size)
        assertEquals("Alice", result[0].name)
        assertEquals("Bob", result[1].name)
    }

    @Test
    fun observePlayersForPlayEmitsUpdatesAfterDelete() = runTest {
        // Insert play and players
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false)
            )
        )

        // Verify initial state
        var result = playerDao.observePlayersForPlay(1).first()
        assertEquals(2, result.size)

        // Delete players
        playerDao.deletePlayersForPlay(1)

        // Verify updated state
        result = playerDao.observePlayersForPlay(1).first()
        assertTrue(result.isEmpty())
    }

    // --- Test 8: deletePlayersForPlays ---

    @Test
    fun deletePlayersForPlaysRemovesPlayersForMultiplePlays() = runTest {
        // Insert multiple plays
        playDao.insertAll(
            listOf(
                createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"),
                createTestPlay(2, parseDateString("2024-01-02"), 200, "Game 2"),
                createTestPlay(3, parseDateString("2024-01-03"), 300, "Game 3")
            )
        )

        // Insert players for each play
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false),
                createTestPlayer(0, 2, "Charlie", null, true),
                createTestPlayer(0, 2, "Dave", null, false),
                createTestPlayer(0, 3, "Eve", null, true)
            )
        )

        // Verify initial state
        assertEquals(2, playerDao.getPlayersForPlay(1).size)
        assertEquals(2, playerDao.getPlayersForPlay(2).size)
        assertEquals(1, playerDao.getPlayersForPlay(3).size)

        // Delete players for plays 1 and 3
        playerDao.deletePlayersForPlays(listOf(1, 3))

        // Verify plays 1 and 3 have no players
        assertTrue(playerDao.getPlayersForPlay(1).isEmpty())
        assertTrue(playerDao.getPlayersForPlay(3).isEmpty())

        // Verify play 2 still has players
        val play2Players = playerDao.getPlayersForPlay(2)
        assertEquals(2, play2Players.size)
        val sortedPlayers = play2Players.sortedBy { it.name }
        assertEquals("Charlie", sortedPlayers[0].name)
        assertEquals("Dave", sortedPlayers[1].name)
    }

    @Test
    fun deletePlayersForPlaysHandlesEmptyList() = runTest {
        // Insert play and players
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false)
            )
        )

        // Verify initial state
        assertEquals(2, playerDao.getPlayersForPlay(1).size)

        // Delete with empty list - should not affect any players
        playerDao.deletePlayersForPlays(emptyList())

        // Verify players still exist
        assertEquals(2, playerDao.getPlayersForPlay(1).size)
    }

    @Test
    fun deletePlayersForPlaysHandlesNonExistentPlayIds() = runTest {
        // Insert play and players
        playDao.insert(createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"))
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 1, "Bob", null, false)
            )
        )

        // Verify initial state
        assertEquals(2, playerDao.getPlayersForPlay(1).size)

        // Delete players for non-existent plays
        playerDao.deletePlayersForPlays(listOf(999, 888))

        // Verify existing players are unaffected
        assertEquals(2, playerDao.getPlayersForPlay(1).size)
    }

    @Test
    fun deletePlayersForPlaysSinglePlayIdWorksCorrectly() = runTest {
        // Insert multiple plays with players
        playDao.insertAll(
            listOf(
                createTestPlay(1, parseDateString("2024-01-01"), 100, "Game 1"),
                createTestPlay(2, parseDateString("2024-01-02"), 200, "Game 2")
            )
        )
        playerDao.insertAll(
            listOf(
                createTestPlayer(0, 1, "Alice", null, true),
                createTestPlayer(0, 2, "Bob", null, true)
            )
        )

        // Delete players for single play
        playerDao.deletePlayersForPlays(listOf(1))

        // Verify only play 1's players are deleted
        assertTrue(playerDao.getPlayersForPlay(1).isEmpty())
        assertEquals(1, playerDao.getPlayersForPlay(2).size)
    }

    // --- Helper functions ---

    private fun createTestPlay(
        id: Long,
        date: Instant,
        gameId: Long,
        gameName: String
    ): PlayEntity {
        return PlayEntity(
            localId = id,
            remoteId = id * 100, // Just a convention for testing
            date = date,
            quantity = 1,
            length = 60,
            incomplete = false,
            location = null,
            gameId = gameId,
            gameName = gameName,
            comments = null,
            syncStatus = PlaySyncStatus.SYNCED
        )
    }

    private fun createTestPlayer(
        id: Long,
        playId: Long,
        name: String,
        username: String?,
        win: Boolean,
        userId: Long? = null,
        startPosition: String? = null,
        color: String? = null,
        score: Int? = null
    ): PlayerEntity {
        return PlayerEntity(
            id = id,
            playId = playId,
            username = username,
            userId = userId,
            name = name,
            startPosition = startPosition,
            color = color,
            score = score,
            win = win
        )
    }
}
